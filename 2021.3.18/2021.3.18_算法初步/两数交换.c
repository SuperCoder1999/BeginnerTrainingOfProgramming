/*
#include"Head.h"

//  ******    领悟了     ******  //

void Exchange_tmp(int a, int b)
{
	int tmp = 0;
	tmp = a;
	a = b;
	b = tmp;
	printf("%d,%d\n", a, b);
	return;
}
// 这种方法不需用解释怎么做的，但是需要会分析它的不足：
// 当然这种方法并没有太大的毛病，要怪就怪谁想出的下面的异或法TAT

void Exchange_sum(int a, int b)
{
	b = a + b;// 只要记住b中存着 a、b的和
	a = b - a;// 右式：把两数之和减掉a，剩下b ； 赋值符：b赋值给a（一定记住b中始终存着两数和，分析的时候我所称呼的b全是指没有相加之前的b，两数的和具体存在哪里不用先考虑，等到会分析过后再考虑为什么和放在b中）
	b = b - a;// 目前情形：a中存着b的值   右式：两数和减去b就得到了a的值  ； 赋值符：将a赋值给b。
	// 如果真的从第一步到第三步，都把两数和单独领出来而不作为b的值，那么分析起来就清晰很多
	// 
	// 现在要解决的是：为什么两数和要存在b中。我一开始听说不用中间变量来交换两数的时候，第一个想法也是这种相加的方法
	// 为什么想到这个和的方法：其实这个做法和生活中的情形很相似，你两只手各拿着一个棒棒糖，你现在要交换过来，可不就是
	// 	将一只手里的棒棒糖先放在另一只手上，再拿走原本另一只手上的？？
	// 
	// 	有了这个实际情况，理解这个算法就容易多了。但是计算机相加之后不是棒棒糖那么好分辨谁是谁，
	// 所以就要进行”用一个数挤出去另一个数“的方法分离。第二步算是容易理解的”分离“，第三步一定记住a存着b，这时就靠b把a出去
	// 如果读第一遍没有理解，结合后面的生活实例尝试自己分析前面三步，不会也不要紧。作为新手，总要多见识见识的，到后面刷题还会遇见它，到那时会须就会了（因为我就是当时不会，后来遇到想明白的）
	printf("%d,%d\n", a, b);
	return;
}
// 分析这个算法，有很大的缺陷，对于两个都接近int范围的数，相加之后必然超过范围，继而导致交换出错


// 了解一下两个规律有助于理解这个算法：任意数异或自己都等于0；0与任意数异或都等于该数
void Exchange_eor(int a, int b)
{
	b = a ^ b; // 这种方法和第二种差不多思想 如果对于上面两个规律不能理解就当这个和上面第二种方法一样是在求和
	a = b ^ a;// 右式：和减去a得到b；赋值符：把b给a（将b作为固定和，b本身没变化过）
	b = b ^ a;// 现在右式：b减去b，得到了a； 赋值号：把a给b（这里当赋值的一刻，b才开始变化）
	printf("%d,%d", a, b);
	return;// 这题结合上一道题，慢慢想一想，想不出来不要紧，以后还会遇到，而且以后的思维会更灵活。只要能再找工作前解决就没问题
	
	// 对于有体验过上面两个规律的同学将做如下讲解
	b = a ^ b;// 和上面利用和的方法一样，这里不要记b中存着a^b ，只要知道有一个数是 a^b
	a = b ^ a;// 整理目前所有已知的信息：一个存着a^b的变量 ；接下来分析右边的式子，a^b 和a 进行异或，相当于b^(a^a),由第一个规律化简就是b^0 ,再由第二个规律化简就是b；赋值符：将b赋值给a
	b = b ^ a;// 现在a中存着b；分析右边的式子：a^b 和b异或（这里脑袋要转过弯哦），相当于a^(b^b),得到a^0，也就是a ；赋值符：将a赋值给b
	// 和上面的加法相同，一定不要想b中存着谁。先搞清为什么各样能完成交换，再把b中存着的对象加入到分析过程
}

int main()
{
	int a = 0, b = 0;

	scanf("%d%d", &a, &b);
	Exchange_tmp(a, b);
	Exchange_sum(a, b);
	Exchange_eor(a, b);// 异或法
	return 0;
}
// 或许你能发现，和的方法 与 异或法 只是运算符变了。当然，这是两个方法中同时把b作为存储a+b和a^b的地方。你可以更换到a中自己写试一试
*/